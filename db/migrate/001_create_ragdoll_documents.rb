# frozen_string_literal: true

# Migration: Create Ragdoll Documents Table
#
# This migration creates the core documents table for the Ragdoll RAG system.
# The ragdoll_documents table stores all document records along with their
# content, metadata, AI-generated summaries, and extracted keywords.
#
# == Table Purpose:
# The documents table serves as the primary storage for all ingested documents
# in the RAG system. Each document can have an attached file (via ActiveStorage)
# and automatically generates summaries and keywords using LLM providers for
# enhanced search capabilities.
#
# == Search Strategy:
# Full-text search operates on the summary and keywords fields rather than
# the raw document content, enabling faster and more relevant search results.
# The FTS5 virtual table provides SQLite full-text search capabilities.
#
# == ActiveStorage Integration:
# Documents support file attachments via ActiveStorage with exactly one file
# per document. Supported formats include PDF, DOCX, text, HTML, and Markdown.
#
class CreateRagdollDocuments < ActiveRecord::Migration[7.0]
  def change
    create_table :ragdoll_documents, comment: 'Core documents table storing document content, metadata, AI-generated summaries and keywords for RAG search' do |t|
      # === Core Document Identity ===
      
      # Document location/source identifier - can be file path, URL, or identifier
      # Used to track the original source of the document content
      t.string :location, null: false, comment: 'Source location of document (file path, URL, or identifier)'
      
      # Human-readable document title, used for display and basic search
      # Auto-extracted from filename or document metadata if not provided
      t.string :title, null: false, comment: 'Human-readable document title for display and search'
      
      # === Document Content ===
      
      # Raw document content as extracted from files or provided directly
      # This is the source content but NOT used directly for search (see summary)
      t.text :content, null: false, comment: 'Raw document content extracted from files or provided directly'
      
      # === AI-Generated Search Fields ===
      
      # AI-generated summary of document content using LLM providers (via ruby_llm)
      # This field is the PRIMARY target for full-text search instead of raw content
      # Generated automatically when content is saved using TextGenerationService
      t.text :summary, comment: 'AI-generated summary using LLM providers, primary field for full-text search'
      
      # AI-extracted keywords for faceted search and categorization
      # Comma-separated keywords generated by LLM or fallback extraction algorithms
      # Used for both full-text search and faceted filtering capabilities
      t.text :keywords, comment: 'AI-extracted comma-separated keywords for faceted search and categorization'
      
      # === Document Classification ===
      
      # Document format type (pdf, docx, text, markdown, html)
      # Determines parsing strategy and content extraction method
      t.string :document_type, null: false, default: 'text', comment: 'Document format type determining parsing strategy (pdf, docx, text, markdown, html)'
      
      # Processing status tracking the document lifecycle
      # Values: pending, processing, processed, error
      # Used to track document ingestion and processing progress
      t.string :status, null: false, default: 'pending', comment: 'Document processing status: pending, processing, processed, error'
      
      # === Metadata Storage ===
      
      # Flexible JSON storage for document metadata, file properties, and custom attributes
      # Stores file size, creation dates, author info, custom tags, etc.
      # Structure varies by document type and source
      t.json :metadata, default: {}, comment: 'Flexible JSON storage for document metadata, file properties, and custom attributes'
      
      # === Timestamps ===
      
      # Standard Rails timestamps for record tracking
      t.timestamps null: false, comment: 'Standard creation and update timestamps'
      
      # === Database Indexes ===
      
      # Primary search and filtering indexes
      t.index :location, comment: 'Index for document source lookup'
      t.index :title, comment: 'Index for title-based search'
      t.index :document_type, comment: 'Index for filtering by document type'
      t.index :status, comment: 'Index for filtering by processing status'
      t.index :created_at, comment: 'Index for chronological sorting'
      t.index [:document_type, :status], comment: 'Composite index for type+status filtering'
      
      # Full-text search indexes for MySQL (if using MySQL)
      if connection.adapter_name.downcase == 'mysql2'
        t.index :summary, type: :fulltext, name: 'index_ragdoll_documents_on_summary_fulltext'
        t.index :keywords, type: :fulltext, name: 'index_ragdoll_documents_on_keywords_fulltext'
      end
    end
    
    # === SQLite Full-Text Search Setup ===
    
    if connection.adapter_name.downcase == 'sqlite'
      # Create FTS5 virtual table for full-text search on summary and keywords
      # This provides fast, sophisticated search capabilities on the AI-generated fields
      execute <<-SQL
        CREATE VIRTUAL TABLE IF NOT EXISTS ragdoll_documents_fts 
        USING fts5(
          title, 
          summary, 
          keywords,
          content='ragdoll_documents',
          content_rowid='id'
        );
      SQL
      
      # === FTS Synchronization Triggers ===
      
      # Trigger to keep FTS table synchronized on INSERT
      execute <<-SQL
        CREATE TRIGGER IF NOT EXISTS ragdoll_documents_fts_insert 
        AFTER INSERT ON ragdoll_documents 
        BEGIN
          INSERT INTO ragdoll_documents_fts(rowid, title, summary, keywords) 
          VALUES (new.id, new.title, new.summary, new.keywords);
        END;
      SQL
      
      # Trigger to keep FTS table synchronized on DELETE
      execute <<-SQL
        CREATE TRIGGER IF NOT EXISTS ragdoll_documents_fts_delete 
        AFTER DELETE ON ragdoll_documents 
        BEGIN
          INSERT INTO ragdoll_documents_fts(ragdoll_documents_fts, rowid, title, summary, keywords) 
          VALUES('delete', old.id, old.title, old.summary, old.keywords);
        END;
      SQL
      
      # Trigger to keep FTS table synchronized on UPDATE
      execute <<-SQL
        CREATE TRIGGER IF NOT EXISTS ragdoll_documents_fts_update 
        AFTER UPDATE ON ragdoll_documents 
        BEGIN
          INSERT INTO ragdoll_documents_fts(ragdoll_documents_fts, rowid, title, summary, keywords) 
          VALUES('delete', old.id, old.title, old.summary, old.keywords);
          INSERT INTO ragdoll_documents_fts(rowid, title, summary, keywords) 
          VALUES (new.id, new.title, new.summary, new.keywords);
        END;
      SQL
    end
  end
  
  def down
    # Clean up FTS triggers and table for SQLite
    if connection.adapter_name.downcase == 'sqlite'
      execute "DROP TRIGGER IF EXISTS ragdoll_documents_fts_insert;"
      execute "DROP TRIGGER IF EXISTS ragdoll_documents_fts_delete;"
      execute "DROP TRIGGER IF EXISTS ragdoll_documents_fts_update;"
      execute "DROP TABLE IF EXISTS ragdoll_documents_fts;"
    end
    
    drop_table :ragdoll_documents
  end
end